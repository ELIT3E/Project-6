/**
 * name: @storyblok/js
 * (c) 2025
 * description: SDK to integrate Storyblok into your project using JavaScript.
 * author: undefined
 */
function re(r, e) {
  if (!e)
    return { src: r, attrs: {} };
  let t = 0, o = 0;
  const s = {}, n = [];
  function l(a, h, d, y, T) {
    typeof a != "number" || a <= h || a >= d ? console.warn(`[StoryblokRichText] - ${y.charAt(0).toUpperCase() + y.slice(1)} value must be a number between ${h} and ${d} (inclusive)`) : T.push(`${y}(${a})`);
  }
  if (typeof e == "object") {
    if (typeof e.width == "number" && e.width > 0 ? (s.width = e.width, t = e.width) : console.warn("[StoryblokRichText] - Width value must be a number greater than 0"), e.height && typeof e.height == "number" && e.height > 0 ? (s.height = e.height, o = e.height) : console.warn("[StoryblokRichText] - Height value must be a number greater than 0"), e.loading && ["lazy", "eager"].includes(e.loading) && (s.loading = e.loading), e.class && (s.class = e.class), e.filters) {
      const { filters: a } = e || {}, { blur: h, brightness: d, fill: y, format: T, grayscale: _, quality: A, rotate: I } = a || {};
      h && l(h, 0, 100, "blur", n), A && l(A, 0, 100, "quality", n), d && l(d, 0, 100, "brightness", n), y && n.push(`fill(${y})`), _ && n.push("grayscale()"), I && [0, 90, 180, 270].includes(e.filters.rotate || 0) && n.push(`rotate(${I})`), T && ["webp", "png", "jpeg"].includes(T) && n.push(`format(${T})`);
    }
    e.srcset && (s.srcset = e.srcset.map((a) => {
      if (typeof a == "number")
        return `${r}/m/${a}x0/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${a}w`;
      if (Array.isArray(a) && a.length === 2) {
        const [h, d] = a;
        return `${r}/m/${h}x${d}/${n.length > 0 ? `filters:${n.join(":")}` : ""} ${h}w`;
      } else {
        console.warn("[StoryblokRichText] - srcset entry must be a number or a tuple of two numbers");
        return;
      }
    }).join(", ")), e.sizes && (s.sizes = e.sizes.join(", "));
  }
  let c = `${r}/m/`;
  return t > 0 && o > 0 && (c = `${c}${t}x${o}/`), n.length > 0 && (c = `${c}filters:${n.join(":")}`), {
    src: c,
    attrs: s
  };
}
var v = /* @__PURE__ */ ((r) => (r.DOCUMENT = "doc", r.HEADING = "heading", r.PARAGRAPH = "paragraph", r.QUOTE = "blockquote", r.OL_LIST = "ordered_list", r.UL_LIST = "bullet_list", r.LIST_ITEM = "list_item", r.CODE_BLOCK = "code_block", r.HR = "horizontal_rule", r.BR = "hard_break", r.IMAGE = "image", r.EMOJI = "emoji", r.COMPONENT = "blok", r.TABLE = "table", r.TABLE_ROW = "tableRow", r.TABLE_CELL = "tableCell", r.TABLE_HEADER = "tableHeader", r))(v || {}), R = /* @__PURE__ */ ((r) => (r.BOLD = "bold", r.STRONG = "strong", r.STRIKE = "strike", r.UNDERLINE = "underline", r.ITALIC = "italic", r.CODE = "code", r.LINK = "link", r.ANCHOR = "anchor", r.STYLED = "styled", r.SUPERSCRIPT = "superscript", r.SUBSCRIPT = "subscript", r.TEXT_STYLE = "textStyle", r.HIGHLIGHT = "highlight", r))(R || {}), F = /* @__PURE__ */ ((r) => (r.TEXT = "text", r))(F || {}), S = /* @__PURE__ */ ((r) => (r.URL = "url", r.STORY = "story", r.ASSET = "asset", r.EMAIL = "email", r))(S || {});
const oe = [
  "area",
  "base",
  "br",
  "col",
  "embed",
  "hr",
  "img",
  "input",
  "link",
  "meta",
  "param",
  "source",
  "track",
  "wbr"
], ne = (r = {}) => Object.keys(r).map((e) => `${e}="${r[e]}"`).join(" "), ie = (r = {}) => Object.keys(r).map((e) => `${e}: ${r[e]}`).join("; ");
function ae(r) {
  return r.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
}
const O = (r) => Object.fromEntries(Object.entries(r).filter(([e, t]) => t !== void 0));
function D(r, e = {}, t) {
  const o = ne(e), s = o ? `${r} ${o}` : r, n = Array.isArray(t) ? t.join("") : t || "";
  if (r) {
    if (oe.includes(r))
      return `<${s}>`;
  } else return n;
  return `<${s}>${n}</${r}>`;
}
function le(r = {}) {
  const e = /* @__PURE__ */ new Map(), {
    renderFn: t = D,
    textFn: o = ae,
    resolvers: s = {},
    optimizeImages: n = !1,
    keyedResolvers: l = !1
  } = r, c = t !== D, a = (i) => (u, p) => {
    const f = u.attrs || {};
    return p.render(i, f, u.children || null);
  }, h = (i, u) => {
    const { src: p, alt: f, title: m, srcset: w, sizes: b } = i.attrs || {};
    let k = p, $ = {};
    if (n) {
      const { src: te, attrs: se } = re(p, n);
      k = te, $ = se;
    }
    const ee = {
      src: k,
      alt: f,
      title: m,
      srcset: w,
      sizes: b,
      ...$
    };
    return u.render("img", O(ee));
  }, d = (i, u) => {
    const { level: p, ...f } = i.attrs || {};
    return u.render(`h${p}`, f, i.children);
  }, y = (i, u) => {
    var p, f, m, w;
    const b = u.render("img", {
      src: (p = i.attrs) == null ? void 0 : p.fallbackImage,
      alt: (f = i.attrs) == null ? void 0 : f.alt,
      style: "width: 1.25em; height: 1.25em; vertical-align: text-top",
      draggable: "false",
      loading: "lazy"
    });
    return u.render("span", {
      "data-type": "emoji",
      "data-name": (m = i.attrs) == null ? void 0 : m.name,
      "data-emoji": (w = i.attrs) == null ? void 0 : w.emoji
    }, b);
  }, T = (i, u) => u.render(
    "pre",
    i.attrs || {},
    u.render("code", {}, i.children || "")
  ), _ = (i, u = !1) => ({ text: p, attrs: f }, m) => {
    const { class: w, id: b, ...k } = f || {}, $ = u ? {
      class: w,
      id: b,
      style: ie(k) || void 0
    } : f || {};
    return m.render(i, O($), p);
  }, A = (i) => C(i), I = (i) => {
    const { marks: u, ...p } = i;
    if ("text" in i) {
      if (u)
        return u.reduce(
          (m, w) => A({ ...w, text: m }),
          A({ ...p, children: p.children })
        );
      const f = i.attrs || {};
      if (l) {
        const m = e.get("txt") || 0;
        e.set("txt", m + 1), f.key = `txt-${m}`;
      }
      return o(p.text, f);
    }
    return "";
  }, H = (i, u) => {
    const { linktype: p, href: f, anchor: m, ...w } = i.attrs || {};
    let b = "";
    switch (p) {
      case S.ASSET:
      case S.URL:
        b = f;
        break;
      case S.EMAIL:
        b = `mailto:${f}`;
        break;
      case S.STORY:
        b = f, m && (b = `${b}#${m}`);
        break;
      default:
        b = f;
        break;
    }
    const k = { ...w };
    return b && (k.href = b), u.render("a", k, i.text);
  }, Y = (i, u) => {
    var p, f;
    return console.warn("[StoryblokRichtText] - BLOK resolver is not available for vanilla usage"), u.render("span", {
      blok: (p = i == null ? void 0 : i.attrs) == null ? void 0 : p.body[0],
      id: (f = i.attrs) == null ? void 0 : f.id,
      style: "display: none"
    });
  }, K = (i, u) => {
    const p = {}, f = u.render("tbody", {}, i.children);
    return u.render("table", p, f);
  }, W = (i, u) => {
    const p = {};
    return u.render("tr", p, i.children);
  }, X = (i, u) => {
    const { colspan: p, rowspan: f, colwidth: m, backgroundColor: w, ...b } = i.attrs || {}, k = {
      ...b
    };
    p > 1 && (k.colspan = p), f > 1 && (k.rowspan = f);
    const $ = [];
    return m && $.push(`width: ${m}px;`), w && $.push(`background-color: ${w};`), $.length > 0 && (k.style = $.join(" ")), u.render("td", O(k), i.children);
  }, Q = (i, u) => {
    const { colspan: p, rowspan: f, colwidth: m, backgroundColor: w, ...b } = i.attrs || {}, k = {
      ...b
    };
    p > 1 && (k.colspan = p), f > 1 && (k.rowspan = f);
    const $ = [];
    return m && $.push(`width: ${m}px;`), w && $.push(`background-color: ${w};`), $.length > 0 && (k.style = $.join(" ")), u.render("th", O(k), i.children);
  }, B = /* @__PURE__ */ new Map([
    [v.DOCUMENT, a("")],
    [v.HEADING, d],
    [v.PARAGRAPH, a("p")],
    [v.UL_LIST, a("ul")],
    [v.OL_LIST, a("ol")],
    [v.LIST_ITEM, a("li")],
    [v.IMAGE, h],
    [v.EMOJI, y],
    [v.CODE_BLOCK, T],
    [v.HR, a("hr")],
    [v.BR, a("br")],
    [v.QUOTE, a("blockquote")],
    [v.COMPONENT, Y],
    [F.TEXT, I],
    [R.LINK, H],
    [R.ANCHOR, H],
    [R.STYLED, _("span", !0)],
    [R.BOLD, _("strong")],
    [R.TEXT_STYLE, _("span", !0)],
    [R.ITALIC, _("em")],
    [R.UNDERLINE, _("u")],
    [R.STRIKE, _("s")],
    [R.CODE, _("code")],
    [R.SUPERSCRIPT, _("sup")],
    [R.SUBSCRIPT, _("sub")],
    [R.HIGHLIGHT, _("mark")],
    [v.TABLE, K],
    [v.TABLE_ROW, W],
    [v.TABLE_CELL, X],
    [v.TABLE_HEADER, Q]
  ]), U = new Map([
    ...B,
    ...Object.entries(s).map(([i, u]) => [i, u])
  ]), Z = () => ({
    render: (i, u = {}, p) => {
      if (l && i) {
        const f = e.get(i) || 0;
        e.set(i, f + 1), u.key = `${i}-${f}`;
      }
      return t(i, u, p);
    },
    originalResolvers: B,
    mergedResolvers: U
  });
  function L(i) {
    const u = U.get(i.type);
    if (!u)
      return console.error("<Storyblok>", `No resolver found for node type ${i.type}`), "";
    const p = Z();
    if (i.type === "text")
      return u(i, p);
    const f = i.content ? i.content.map(C) : void 0;
    return u({
      ...i,
      children: f
    }, p);
  }
  function C(i) {
    return i.type === "doc" ? c ? i.content.map(L) : i.content.map(L).join("") : Array.isArray(i) ? i.map(L) : L(i);
  }
  return {
    render: C
  };
}
let M = !1;
const z = [], J = (r) => new Promise((e, t) => {
  if (typeof window > "u") {
    t(new Error("Cannot load Storyblok bridge: window is undefined (server-side environment)"));
    return;
  }
  if (window.storyblokRegisterEvent = (s) => {
    if (!window.location.search.includes("_storyblok")) {
      console.warn("You are not in Draft Mode or in the Visual Editor.");
      return;
    }
    M ? s() : z.push(s);
  }, document.getElementById("storyblok-javascript-bridge")) {
    e(void 0);
    return;
  }
  const o = document.createElement("script");
  o.async = !0, o.src = r, o.id = "storyblok-javascript-bridge", o.onerror = (s) => t(s), o.onload = (s) => {
    z.forEach((n) => n()), M = !0, e(s);
  }, document.getElementsByTagName("head")[0].appendChild(o);
});
var ce = Object.defineProperty, he = (r, e, t) => e in r ? ce(r, e, { enumerable: !0, configurable: !0, writable: !0, value: t }) : r[e] = t, g = (r, e, t) => he(r, typeof e != "symbol" ? e + "" : e, t);
class ue extends Error {
  constructor(e) {
    super(e), this.name = "AbortError";
  }
}
function de(r, e, t) {
  if (!Number.isFinite(e))
    throw new TypeError("Expected `limit` to be a finite number");
  if (!Number.isFinite(t))
    throw new TypeError("Expected `interval` to be a finite number");
  const o = [];
  let s = [], n = 0, l = !1;
  const c = async () => {
    n++;
    const h = o.shift();
    if (h)
      try {
        const y = await r(...h.args);
        h.resolve(y);
      } catch (y) {
        h.reject(y);
      }
    const d = setTimeout(() => {
      n--, o.length > 0 && c(), s = s.filter((y) => y !== d);
    }, t);
    s.includes(d) || s.push(d);
  }, a = (...h) => l ? Promise.reject(
    new Error(
      "Throttled function is already aborted and not accepting new promises"
    )
  ) : new Promise((d, y) => {
    o.push({
      resolve: d,
      reject: y,
      args: h
    }), n < e && c();
  });
  return a.abort = () => {
    l = !0, s.forEach(clearTimeout), s = [], o.forEach(
      (h) => h.reject(() => new ue("Throttle function aborted"))
    ), o.length = 0;
  }, a;
}
const G = (r = "") => r.includes("/cdn/"), pe = (r, e = 25, t = 1) => ({
  ...r,
  per_page: e,
  page: t
}), fe = (r) => new Promise((e) => setTimeout(e, r)), ye = (r = 0, e) => Array.from({ length: r }, e), ge = (r = 0, e = r) => {
  const t = Math.abs(e - r) || 0, o = r < e ? 1 : -1;
  return ye(t, (s, n) => n * o + r);
}, me = async (r, e) => Promise.all(r.map(e)), be = (r = [], e) => r.map(e).reduce((t, o) => [...t, ...o], []), N = (r, e, t) => {
  const o = [];
  for (const s in r) {
    if (!Object.prototype.hasOwnProperty.call(r, s))
      continue;
    const n = r[s];
    if (n == null)
      continue;
    const l = t ? "" : encodeURIComponent(s);
    let c;
    typeof n == "object" ? c = N(
      n,
      e ? e + encodeURIComponent(`[${l}]`) : l,
      Array.isArray(n)
    ) : c = `${e ? e + encodeURIComponent(`[${l}]`) : l}=${encodeURIComponent(n)}`, o.push(c);
  }
  return o.join("&");
}, V = (r) => {
  const e = {
    eu: "api.storyblok.com",
    us: "api-us.storyblok.com",
    cn: "app.storyblokchina.cn",
    ap: "api-ap.storyblok.com",
    ca: "api-ca.storyblok.com"
  };
  return e[r] ?? e.eu;
};
class ve {
  constructor(e) {
    g(this, "baseURL"), g(this, "timeout"), g(this, "headers"), g(this, "responseInterceptor"), g(this, "fetch"), g(this, "ejectInterceptor"), g(this, "url"), g(this, "parameters"), g(this, "fetchOptions"), this.baseURL = e.baseURL, this.headers = e.headers || new Headers(), this.timeout = e != null && e.timeout ? e.timeout * 1e3 : 0, this.responseInterceptor = e.responseInterceptor, this.fetch = (...t) => e.fetch ? e.fetch(...t) : fetch(...t), this.ejectInterceptor = !1, this.url = "", this.parameters = {}, this.fetchOptions = {};
  }
  /**
   *
   * @param url string
   * @param params ISbStoriesParams
   * @returns Promise<ISbResponse | Error>
   */
  get(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("get");
  }
  post(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("post");
  }
  put(e, t) {
    return this.url = e, this.parameters = t, this._methodHandler("put");
  }
  delete(e, t) {
    return this.url = e, this.parameters = t ?? {}, this._methodHandler("delete");
  }
  async _responseHandler(e) {
    const t = [], o = {
      data: {},
      headers: {},
      status: 0,
      statusText: ""
    };
    e.status !== 204 && await e.json().then((s) => {
      o.data = s;
    });
    for (const s of e.headers.entries())
      t[s[0]] = s[1];
    return o.headers = { ...t }, o.status = e.status, o.statusText = e.statusText, o;
  }
  async _methodHandler(e) {
    let t = `${this.baseURL}${this.url}`, o = null;
    e === "get" ? t = `${this.baseURL}${this.url}?${N(this.parameters)}` : o = JSON.stringify(this.parameters);
    const s = new URL(t), n = new AbortController(), { signal: l } = n;
    let c;
    this.timeout && (c = setTimeout(() => n.abort(), this.timeout));
    try {
      const a = await this.fetch(`${s}`, {
        method: e,
        headers: this.headers,
        body: o,
        signal: l,
        ...this.fetchOptions
      });
      this.timeout && clearTimeout(c);
      const h = await this._responseHandler(
        a
      );
      return this.responseInterceptor && !this.ejectInterceptor ? this._statusHandler(this.responseInterceptor(h)) : this._statusHandler(h);
    } catch (a) {
      return {
        message: a
      };
    }
  }
  setFetchOptions(e = {}) {
    Object.keys(e).length > 0 && "method" in e && delete e.method, this.fetchOptions = { ...e };
  }
  eject() {
    this.ejectInterceptor = !0;
  }
  /**
   * Normalizes error messages from different response structures
   * @param data The response data that might contain error information
   * @returns A normalized error message string
   */
  _normalizeErrorMessage(e) {
    if (Array.isArray(e))
      return e[0] || "Unknown error";
    if (e && typeof e == "object") {
      if (e.error)
        return e.error;
      for (const t in e) {
        if (Array.isArray(e[t]))
          return `${t}: ${e[t][0]}`;
        if (typeof e[t] == "string")
          return `${t}: ${e[t]}`;
      }
      if (e.slug)
        return e.slug;
    }
    return "Unknown error";
  }
  _statusHandler(e) {
    const t = /20[0-6]/g;
    return new Promise((o, s) => {
      if (t.test(`${e.status}`))
        return o(e);
      const n = {
        message: this._normalizeErrorMessage(e.data),
        status: e.status,
        response: e
      };
      s(n);
    });
  }
}
const q = "SB-Agent", P = {
  defaultAgentName: "SB-JS-CLIENT",
  defaultAgentVersion: "SB-Agent-Version",
  packageVersion: "7.0.0"
}, ke = {
  PUBLISHED: "published"
};
let j = {};
const E = {};
class we {
  /**
   *
   * @param config ISbConfig interface
   * @param pEndpoint string, optional
   */
  constructor(e, t) {
    g(this, "client"), g(this, "maxRetries"), g(this, "retriesDelay"), g(this, "throttle"), g(this, "accessToken"), g(this, "cache"), g(this, "resolveCounter"), g(this, "relations"), g(this, "links"), g(this, "version"), g(this, "richTextResolver"), g(this, "resolveNestedRelations"), g(this, "stringifiedStoriesCache"), g(this, "inlineAssets");
    let o = e.endpoint || t;
    if (!o) {
      const l = e.https === !1 ? "http" : "https";
      e.oauthToken ? o = `${l}://${V(e.region)}/v1` : o = `${l}://${V(e.region)}/v2`;
    }
    const s = new Headers();
    s.set("Content-Type", "application/json"), s.set("Accept", "application/json"), e.headers && (e.headers.constructor.name === "Headers" ? e.headers.entries().toArray() : Object.entries(e.headers)).forEach(([l, c]) => {
      s.set(l, c);
    }), s.has(q) || (s.set(q, P.defaultAgentName), s.set(
      P.defaultAgentVersion,
      P.packageVersion
    ));
    let n = 5;
    e.oauthToken && (s.set("Authorization", e.oauthToken), n = 3), e.rateLimit && (n = e.rateLimit), this.maxRetries = e.maxRetries || 10, this.retriesDelay = 300, this.throttle = de(
      this.throttledRequest.bind(this),
      n,
      1e3
    ), this.accessToken = e.accessToken || "", this.relations = {}, this.links = {}, this.cache = e.cache || { clear: "manual" }, this.resolveCounter = 0, this.resolveNestedRelations = e.resolveNestedRelations || !0, this.stringifiedStoriesCache = {}, this.version = e.version || ke.PUBLISHED, this.inlineAssets = e.inlineAssets || !1, this.client = new ve({
      baseURL: o,
      timeout: e.timeout || 0,
      headers: s,
      responseInterceptor: e.responseInterceptor,
      fetch: e.fetch
    });
  }
  parseParams(e) {
    return e.token || (e.token = this.getToken()), e.cv || (e.cv = E[e.token]), Array.isArray(e.resolve_relations) && (e.resolve_relations = e.resolve_relations.join(",")), typeof e.resolve_relations < "u" && (e.resolve_level = 2), e;
  }
  factoryParamOptions(e, t) {
    return G(e) ? this.parseParams(t) : t;
  }
  makeRequest(e, t, o, s, n) {
    const l = this.factoryParamOptions(
      e,
      pe(t, o, s)
    );
    return this.cacheResponse(e, l, void 0, n);
  }
  get(e, t = {}, o) {
    t || (t = {});
    const s = `/${e}`;
    G(s) && (t.version = t.version || this.version);
    const n = this.factoryParamOptions(s, t);
    return this.cacheResponse(s, n, void 0, o);
  }
  async getAll(e, t = {}, o, s) {
    const n = (t == null ? void 0 : t.per_page) || 25, l = `/${e}`.replace(/\/$/, ""), c = o ?? l.substring(l.lastIndexOf("/") + 1);
    t.version = t.version || this.version;
    const a = 1, h = await this.makeRequest(
      l,
      t,
      n,
      a,
      s
    ), d = h.total ? Math.ceil(h.total / n) : 1, y = await me(
      ge(a, d),
      (T) => this.makeRequest(l, t, n, T + 1, s)
    );
    return be([h, ...y], (T) => Object.values(T.data[c]));
  }
  post(e, t = {}, o) {
    const s = `/${e}`;
    return this.throttle("post", s, t, o);
  }
  put(e, t = {}, o) {
    const s = `/${e}`;
    return this.throttle("put", s, t, o);
  }
  delete(e, t = {}, o) {
    t || (t = {});
    const s = `/${e}`;
    return this.throttle("delete", s, t, o);
  }
  getStories(e = {}, t) {
    return this._addResolveLevel(e), this.get("cdn/stories", e, t);
  }
  getStory(e, t = {}, o) {
    return this._addResolveLevel(t), this.get(`cdn/stories/${e}`, t, o);
  }
  getToken() {
    return this.accessToken;
  }
  ejectInterceptor() {
    this.client.eject();
  }
  _addResolveLevel(e) {
    typeof e.resolve_relations < "u" && (e.resolve_level = 2);
  }
  _cleanCopy(e) {
    return JSON.parse(JSON.stringify(e));
  }
  _insertLinks(e, t, o) {
    const s = e[t];
    s && s.fieldtype === "multilink" && s.linktype === "story" && typeof s.id == "string" && this.links[o][s.id] ? s.story = this._cleanCopy(this.links[o][s.id]) : s && s.linktype === "story" && typeof s.uuid == "string" && this.links[o][s.uuid] && (s.story = this._cleanCopy(this.links[o][s.uuid]));
  }
  /**
   *
   * @param resolveId A counter number as a string
   * @param uuid The uuid of the story
   * @returns string | object
   */
  getStoryReference(e, t) {
    return this.relations[e][t] ? JSON.parse(this.stringifiedStoriesCache[t] || JSON.stringify(this.relations[e][t])) : t;
  }
  /**
   * Resolves a field's value by replacing UUIDs with their corresponding story references
   * @param jtree - The JSON tree object containing the field to resolve
   * @param treeItem - The key of the field to resolve
   * @param resolveId - The unique identifier for the current resolution context
   *
   * This method handles both single string UUIDs and arrays of UUIDs:
   * - For single strings: directly replaces the UUID with the story reference
   * - For arrays: maps through each UUID and replaces with corresponding story references
   */
  _resolveField(e, t, o) {
    const s = e[t];
    typeof s == "string" ? e[t] = this.getStoryReference(o, s) : Array.isArray(s) && (e[t] = s.map(
      (n) => this.getStoryReference(o, n)
    ).filter(Boolean));
  }
  /**
   * Inserts relations into the JSON tree by resolving references
   * @param jtree - The JSON tree object to process
   * @param treeItem - The current field being processed
   * @param fields - The relation patterns to resolve (string or array of strings)
   * @param resolveId - The unique identifier for the current resolution context
   *
   * This method handles two types of relation patterns:
   * 1. Nested relations: matches fields that end with the current field name
   *    Example: If treeItem is "event_type", it matches patterns like "*.event_type"
   *
   * 2. Direct component relations: matches exact component.field patterns
   *    Example: "event.event_type" for component "event" and field "event_type"
   *
   * The method supports both string and array formats for the fields parameter,
   * allowing flexible specification of relation patterns.
   */
  _insertRelations(e, t, o, s) {
    if (Array.isArray(o) ? o.find((l) => l.endsWith(`.${t}`)) : o.endsWith(`.${t}`)) {
      this._resolveField(e, t, s);
      return;
    }
    const n = e.component ? `${e.component}.${t}` : t;
    (Array.isArray(o) ? o.includes(n) : o === n) && this._resolveField(e, t, s);
  }
  /**
   * Recursively traverses and resolves relations in the story content tree
   * @param story - The story object containing the content to process
   * @param fields - The relation patterns to resolve
   * @param resolveId - The unique identifier for the current resolution context
   */
  iterateTree(e, t, o) {
    const s = (n, l = "") => {
      if (!(!n || n._stopResolving)) {
        if (Array.isArray(n))
          n.forEach((c, a) => s(c, `${l}[${a}]`));
        else if (typeof n == "object")
          for (const c in n) {
            const a = l ? `${l}.${c}` : c;
            (n.component && n._uid || n.type === "link") && (this._insertRelations(n, c, t, o), this._insertLinks(n, c, o)), s(n[c], a);
          }
      }
    };
    s(e.content);
  }
  async resolveLinks(e, t, o) {
    let s = [];
    if (e.link_uuids) {
      const n = e.link_uuids.length, l = [], c = 50;
      for (let a = 0; a < n; a += c) {
        const h = Math.min(n, a + c);
        l.push(e.link_uuids.slice(a, h));
      }
      for (let a = 0; a < l.length; a++)
        (await this.getStories({
          per_page: c,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: l[a].join(",")
        })).data.stories.forEach(
          (h) => {
            s.push(h);
          }
        );
    } else
      s = e.links;
    s.forEach((n) => {
      this.links[o][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  async resolveRelations(e, t, o) {
    let s = [];
    if (e.rel_uuids) {
      const n = e.rel_uuids.length, l = [], c = 50;
      for (let a = 0; a < n; a += c) {
        const h = Math.min(n, a + c);
        l.push(e.rel_uuids.slice(a, h));
      }
      for (let a = 0; a < l.length; a++)
        (await this.getStories({
          per_page: c,
          language: t.language,
          version: t.version,
          starts_with: t.starts_with,
          by_uuids: l[a].join(","),
          excluding_fields: t.excluding_fields
        })).data.stories.forEach((h) => {
          s.push(h);
        });
      s.length > 0 && (e.rels = s, delete e.rel_uuids);
    } else
      s = e.rels;
    s && s.length > 0 && s.forEach((n) => {
      this.relations[o][n.uuid] = {
        ...n,
        _stopResolving: !0
      };
    });
  }
  /**
   *
   * @param responseData
   * @param params
   * @param resolveId
   * @description Resolves the relations and links of the stories
   * @returns Promise<void>
   *
   */
  async resolveStories(e, t, o) {
    var s, n;
    let l = [];
    if (this.links[o] = {}, this.relations[o] = {}, typeof t.resolve_relations < "u" && t.resolve_relations.length > 0 && (typeof t.resolve_relations == "string" && (l = t.resolve_relations.split(",")), await this.resolveRelations(e, t, o)), t.resolve_links && ["1", "story", "url", "link"].includes(t.resolve_links) && ((s = e.links) != null && s.length || (n = e.link_uuids) != null && n.length) && await this.resolveLinks(e, t, o), this.resolveNestedRelations)
      for (const c in this.relations[o])
        this.iterateTree(
          this.relations[o][c],
          l,
          o
        );
    e.story ? this.iterateTree(e.story, l, o) : e.stories.forEach((c) => {
      this.iterateTree(c, l, o);
    }), this.stringifiedStoriesCache = {}, delete this.links[o], delete this.relations[o];
  }
  async cacheResponse(e, t, o, s) {
    const n = N({ url: e, params: t }), l = this.cacheProvider();
    if (t.version === "published" && e !== "/cdn/spaces/me") {
      const c = await l.get(n);
      if (c)
        return Promise.resolve(c);
    }
    return new Promise(async (c, a) => {
      var h;
      try {
        const d = await this.throttle(
          "get",
          e,
          t,
          s
        );
        if (d.status !== 200)
          return a(d);
        let y = { data: d.data, headers: d.headers };
        if ((h = d.headers) != null && h["per-page"] && (y = Object.assign({}, y, {
          perPage: d.headers["per-page"] ? Number.parseInt(d.headers["per-page"]) : 0,
          total: d.headers["per-page"] ? Number.parseInt(d.headers.total) : 0
        })), y.data.story || y.data.stories) {
          const _ = this.resolveCounter = ++this.resolveCounter % 1e3;
          await this.resolveStories(y.data, t, `${_}`), y = await this.processInlineAssets(y);
        }
        t.version === "published" && e !== "/cdn/spaces/me" && await l.set(n, y);
        const T = this.cache.clear === "onpreview" && t.version === "draft" || this.cache.clear === "auto";
        return t.token && y.data.cv && (T && E[t.token] && E[t.token] !== y.data.cv && await this.flushCache(), E[t.token] = y.data.cv), c(y);
      } catch (d) {
        if (d.response && d.status === 429 && (o = typeof o > "u" ? 0 : o + 1, o < this.maxRetries))
          return console.log(
            `Hit rate limit. Retrying in ${this.retriesDelay / 1e3} seconds.`
          ), await fe(this.retriesDelay), this.cacheResponse(e, t, o).then(c).catch(a);
        a(d);
      }
    });
  }
  throttledRequest(e, t, o, s) {
    return this.client.setFetchOptions(s), this.client[e](t, o);
  }
  cacheVersions() {
    return E;
  }
  cacheVersion() {
    return E[this.accessToken];
  }
  setCacheVersion(e) {
    this.accessToken && (E[this.accessToken] = e);
  }
  clearCacheVersion() {
    this.accessToken && (E[this.accessToken] = 0);
  }
  cacheProvider() {
    switch (this.cache.type) {
      case "memory":
        return {
          get(e) {
            return Promise.resolve(j[e]);
          },
          getAll() {
            return Promise.resolve(j);
          },
          set(e, t) {
            return j[e] = t, Promise.resolve(void 0);
          },
          flush() {
            return j = {}, Promise.resolve(void 0);
          }
        };
      case "custom":
        if (this.cache.custom)
          return this.cache.custom;
      // eslint-disable-next-line no-fallthrough
      default:
        return {
          get() {
            return Promise.resolve();
          },
          getAll() {
            return Promise.resolve(void 0);
          },
          set() {
            return Promise.resolve(void 0);
          },
          flush() {
            return Promise.resolve(void 0);
          }
        };
    }
  }
  async flushCache() {
    return await this.cacheProvider().flush(), this.clearCacheVersion(), this;
  }
  async processInlineAssets(e) {
    if (!this.inlineAssets)
      return e;
    const t = (o) => {
      if (!o || typeof o != "object")
        return o;
      if (Array.isArray(o))
        return o.map((n) => t(n));
      let s = { ...o };
      s.fieldtype === "asset" && Array.isArray(e.data.assets) && (s = {
        ...s,
        ...e.data.assets.find((n) => n.id === s.id)
      });
      for (const n in s)
        typeof s[n] == "object" && (s[n] = t(s[n]));
      return s;
    };
    return e.data.story && (e.data.story.content = t(e.data.story.content)), e.data.stories && (e.data.stories = e.data.stories.map((o) => (o.content = t(o.content), o))), e;
  }
}
const Te = (r = {}) => {
  const { apiOptions: e } = r;
  if (!e || !e.accessToken) {
    console.error(
      "You need to provide an access token to interact with Storyblok API. Read https://www.storyblok.com/docs/api/content-delivery#topics/authentication"
    );
    return;
  }
  return { storyblokApi: new we(e) };
}, _e = (r) => {
  if (typeof r != "object" || typeof r._editable > "u")
    return {};
  try {
    const e = JSON.parse(
      r._editable.replace(/^<!--#storyblok#/, "").replace(/-->$/, "")
    );
    return e ? {
      "data-blok-c": JSON.stringify(e),
      "data-blok-uid": `${e.id}-${e.uid}`
    } : {};
  } catch {
    return {};
  }
};
let x = "https://app.storyblok.com/f/storyblok-v2-latest.js";
const $e = (r, e, t = {}) => {
  var c;
  const s = !(typeof window > "u") && typeof window.storyblokRegisterEvent < "u", n = new URL((c = window.location) == null ? void 0 : c.href).searchParams.get(
    "_storyblok"
  ), l = n !== null && +n === r;
  if (!(!s || !l)) {
    if (!r) {
      console.warn("Story ID is not defined. Please provide a valid ID.");
      return;
    }
    window.storyblokRegisterEvent(() => {
      new window.StoryblokBridge(t).on(["input", "published", "change"], (h) => {
        var d;
        h && (h.action === "input" && ((d = h.story) == null ? void 0 : d.id) === r ? e(h.story) : (h.action === "change" || h.action === "published") && h.storyId === r && window.location.reload());
      });
    });
  }
}, Re = (r = {}) => {
  var d, y;
  const {
    bridge: e,
    accessToken: t,
    use: o = [],
    apiOptions: s = {},
    bridgeUrl: n
  } = r;
  s.accessToken = s.accessToken || t;
  const l = { bridge: e, apiOptions: s };
  let c = {};
  o.forEach((T) => {
    c = { ...c, ...T(l) };
  }), n && (x = n);
  const h = !(typeof window > "u") && ((y = (d = window.location) == null ? void 0 : d.search) == null ? void 0 : y.includes("_storyblok_tk"));
  return e !== !1 && h && J(x), c;
};
function Ee(r, e) {
  return le(e).render(r);
}
const Ae = () => J(x);
export {
  v as BlockTypes,
  R as MarkTypes,
  F as TextTypes,
  Te as apiPlugin,
  Ae as loadStoryblokBridge,
  $e as registerStoryblokBridge,
  Ee as renderRichText,
  le as richTextResolver,
  _e as storyblokEditable,
  Re as storyblokInit,
  $e as useStoryblokBridge
};

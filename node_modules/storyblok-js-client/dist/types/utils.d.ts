import { AsyncFn, ISbResult, ISbStoriesParams } from './interfaces';
interface ISbParams extends ISbStoriesParams {
    [key: string]: any;
}
type ArrayFn = (...args: any) => void;
type FlatMapFn = (...args: any) => [] | any;
type RangeFn = (...args: any) => [];
/**
 * Checks if a URL is a CDN URL
 * @param url - The URL to check
 * @returns boolean indicating if the URL is a CDN URL
 */
export declare const isCDNUrl: (url?: string) => boolean;
/**
 * Gets pagination options for the API request
 * @param options - The base options
 * @param perPage - Number of items per page
 * @param page - Current page number
 * @returns Object with pagination options
 */
export declare const getOptionsPage: (options: ISbStoriesParams, perPage?: number, page?: number) => {
    per_page: number;
    page: number;
    resolve_level?: number;
    _stopResolving?: boolean;
    by_slugs?: string;
    by_uuids?: string;
    by_uuids_ordered?: string;
    component?: string;
    content_type?: string;
    cv?: number;
    datasource?: string;
    dimension?: string;
    excluding_fields?: string;
    excluding_ids?: string;
    excluding_slugs?: string;
    fallback_lang?: string;
    filename?: string;
    filter_query?: any;
    first_published_at_gt?: string;
    first_published_at_lt?: string;
    from_release?: string;
    is_startpage?: boolean;
    language?: string;
    level?: number;
    published_at_gt?: string;
    published_at_lt?: string;
    resolve_assets?: number;
    resolve_links?: "link" | "url" | "story" | "0" | "1" | "link";
    resolve_links_level?: 1 | 2;
    resolve_relations?: string | string[];
    search_term?: string;
    size?: string;
    sort_by?: string;
    starts_with?: string;
    token?: string;
    version?: import('./constants').StoryblokContentVersionKeys;
    with_tag?: string;
    alternates?: import('./interfaces').ISbAlternateObject[] | undefined;
    breadcrumbs?: import('./interfaces').ISbLinkURLObject[] | undefined;
    content?: (import('./interfaces').ISbComponentType<string> & {
        [index: string]: any;
    }) | undefined;
    created_at?: string | undefined;
    deleted_at?: string | undefined;
    default_full_slug?: string | null | undefined;
    default_root?: string | undefined;
    disble_fe_editor?: boolean | undefined;
    favourite_for_user_ids?: number[] | null | undefined;
    first_published_at?: string | null | undefined;
    full_slug?: string | undefined;
    group_id?: string | undefined;
    id?: number | undefined;
    imported_at?: string | undefined;
    is_folder?: boolean | undefined;
    lang?: string | undefined;
    last_author?: {
        id: number;
        userid: string;
    } | undefined;
    last_author_id?: number | undefined;
    localized_paths?: import('./interfaces').LocalizedPath[] | null | undefined;
    meta_data?: any;
    name?: string | undefined;
    parent?: import('./interfaces').ISbStoryData | undefined;
    parent_id?: number | null | undefined;
    path?: string | undefined;
    pinned?: "1" | boolean | undefined;
    position?: number | undefined;
    preview_token?: import('./interfaces').PreviewToken | undefined;
    published?: boolean | undefined;
    published_at?: string | null | undefined;
    release_id?: number | null | undefined;
    scheduled_date?: string | null | undefined;
    slug?: string | undefined;
    sort_by_date?: string | null | undefined;
    tag_list?: string[] | undefined;
    translated_slugs?: {
        path: string;
        name: string | null;
        lang: import('./interfaces').ISbStoryData["lang"];
    }[] | null | undefined;
    unpublished_changes?: boolean | undefined;
    updated_at?: string | undefined;
    uuid?: string | undefined;
    by_ids?: string | undefined;
    contain_component?: string | undefined;
    folder_only?: boolean | undefined;
    in_release?: string | undefined;
    in_trash?: boolean | undefined;
    is_published?: boolean | undefined;
    in_workflow_stages?: string | undefined;
    search?: string | undefined;
    story_only?: boolean | undefined;
    text_search?: string | undefined;
    with_parent?: number | undefined;
    with_slug?: string | undefined;
    in_folder?: string;
    is_private?: boolean;
    by_alt?: string;
    by_copyright?: string;
    by_title?: string;
};
/**
 * Creates a promise that resolves after the specified milliseconds
 * @param ms - Milliseconds to delay
 * @returns Promise that resolves after the delay
 */
export declare const delay: (ms: number) => Promise<void>;
/**
 * Creates an array of specified length using a mapping function
 * @param length - Length of the array
 * @param func - Mapping function
 * @returns Array of specified length
 */
export declare const arrayFrom: (length: number | undefined, func: ArrayFn) => void[];
/**
 * Creates an array of numbers in the specified range
 * @param start - Start of the range
 * @param end - End of the range
 * @returns Array of numbers in the range
 */
export declare const range: (start?: number, end?: number) => Array<any>;
/**
 * Maps an array asynchronously
 * @param arr - Array to map
 * @param func - Async mapping function
 * @returns Promise resolving to mapped array
 */
export declare const asyncMap: (arr: RangeFn[], func: AsyncFn) => Promise<([] | ISbResult)[]>;
/**
 * Flattens an array using a mapping function
 * @param arr - Array to flatten
 * @param func - Mapping function
 * @returns Flattened array
 */
export declare const flatMap: (arr: ISbResult[] | undefined, func: FlatMapFn) => any;
/**
 * Stringifies an object into a URL query string
 * @param params - Parameters to stringify
 * @param prefix - Prefix for nested keys
 * @param isArray - Whether the current level is an array
 * @returns Stringified query parameters
 */
export declare const stringify: (params: ISbParams, prefix?: string, isArray?: boolean) => string;
/**
 * Gets the base URL for a specific region
 * @param regionCode - Region code (eu, us, cn, ap, ca)
 * @returns Base URL for the region
 */
export declare const getRegionURL: (regionCode?: string) => string;
/**
 * Escapes HTML special characters in a string
 * @param string - String to escape
 * @returns Escaped string
 */
export declare const escapeHTML: (string: string) => string;
export {};
